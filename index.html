<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>TTS Engine â€” OpusLibre</title>
<style>
  body { font-family: monospace; background: #111; color: #0f0; padding: 20px; }
  #status { font-size: 1.2em; }
  #progress { margin-top: 10px; color: #888; }
</style>
</head>
<body>
<div id="status">Initializing...</div>
<div id="progress"></div>
<script>
(async function() {
  const params = new URLSearchParams(location.search);
  const text = params.get('text') || '';
  const lang = params.get('lang') || 'fr';
  const status = document.getElementById('status');
  const progress = document.getElementById('progress');

  window.ttsComplete = false;
  window.ttsError = null;

  if (!text) {
    status.textContent = 'No text provided. Usage: ?text=Hello+world&lang=fr';
    return;
  }

  function log(msg) {
    progress.innerHTML += msg + '<br>';
  }

  // Split text into chunks of max 180 chars on sentence boundaries
  function splitText(t, maxLen) {
    maxLen = maxLen || 180;
    const chunks = [];
    // Split on sentence boundaries first
    const parts = t.split(/(?<=[.!?])\s+/);
    let current = '';
    for (const part of parts) {
      if (part.length > maxLen) {
        // Split long part on commas/spaces
        if (current) { chunks.push(current.trim()); current = ''; }
        for (let i = 0; i < part.length; i += maxLen) {
          chunks.push(part.slice(i, i + maxLen).trim());
        }
      } else if ((current + ' ' + part).trim().length > maxLen) {
        if (current) chunks.push(current.trim());
        current = part;
      } else {
        current = (current + ' ' + part).trim();
      }
    }
    if (current) chunks.push(current.trim());
    return chunks.filter(c => c.length > 0);
  }

  async function fetchChunkWithRetry(chunk, lang, retries) {
    retries = retries || 3;
    const encoded = encodeURIComponent(chunk);
    const ttsUrl = 'https://translate.google.com/translate_tts?ie=UTF-8&q=' + encoded + '&tl=' + lang + '&client=tw-ob';
    const proxies = [
      'https://corsproxy.io/?' + encodeURIComponent(ttsUrl),
      'https://api.allorigins.win/raw?url=' + encodeURIComponent(ttsUrl),
      ttsUrl  // Direct (may work if CORS allows audio)
    ];

    for (let p = 0; p < proxies.length; p++) {
      for (let r = 0; r < retries; r++) {
        try {
          const resp = await fetch(proxies[p], { headers: { 'User-Agent': 'Mozilla/5.0' } });
          if (resp.ok) {
            const buf = await resp.arrayBuffer();
            if (buf.byteLength > 100) return buf;
          }
        } catch(e) {
          log('Proxy ' + p + ' attempt ' + (r+1) + ' failed: ' + e.message);
        }
        await new Promise(res => setTimeout(res, 500));
      }
    }
    throw new Error('All proxies failed for chunk: ' + chunk.slice(0, 30));
  }

  try {
    status.textContent = 'Generating TTS...';
    const chunks = splitText(text);
    log('Text: ' + text.length + ' chars, ' + chunks.length + ' chunk(s)');

    const buffers = [];
    for (let i = 0; i < chunks.length; i++) {
      log('Fetching chunk ' + (i+1) + '/' + chunks.length + '...');
      const buf = await fetchChunkWithRetry(chunks[i], lang);
      buffers.push(buf);
      log('Chunk ' + (i+1) + ' OK (' + buf.byteLength + ' bytes)');
    }

    // Concatenate all MP3 buffers
    const totalLen = buffers.reduce(function(a, b) { return a + b.byteLength; }, 0);
    const combined = new Uint8Array(totalLen);
    let offset = 0;
    for (const buf of buffers) {
      combined.set(new Uint8Array(buf), offset);
      offset += buf.byteLength;
    }

    const blob = new Blob([combined], { type: 'audio/mpeg' });
    const url = URL.createObjectURL(blob);

    const a = document.createElement('a');
    a.href = url;
    a.download = 'tts-output.mp3';
    document.body.appendChild(a);
    a.click();

    status.textContent = 'Done! ' + totalLen + ' bytes downloaded.';
    window.ttsComplete = true;
    window.ttsByteSize = totalLen;

  } catch(e) {
    status.textContent = 'Error: ' + e.message;
    window.ttsError = e.message;
  }
})();
</script>
</body>
</html>
