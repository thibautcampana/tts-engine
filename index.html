<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>TTS Engine — OpusLibre</title>
<style>
  body { font-family: monospace; background: #111; color: #0f0; padding: 20px; }
  #status { font-size: 1.2em; }
  #progress { margin-top: 10px; color: #888; font-size: 0.9em; }
</style>
</head>
<body>
<div id="status">Initializing...</div>
<div id="progress"></div>
<script>
(async function() {
  const params = new URLSearchParams(location.search);
  const text   = params.get('text') || '';
  const lang   = params.get('lang') || 'fr';
  const voice  = params.get('voice') || '';  // e.g. "Henri", "Denise", "Eloise", "google"

  const status   = document.getElementById('status');
  const progress = document.getElementById('progress');

  window.ttsComplete = false;
  window.ttsError    = null;

  if (!text) {
    status.textContent = 'Usage: ?text=Bonjour&lang=fr&voice=Denise';
    return;
  }

  function log(msg) { progress.innerHTML += msg + '<br>'; }

  function splitText(t, maxLen) {
    maxLen = maxLen || 180;
    const chunks = [];
    const parts  = t.split(/(?<=[.!?])\s+/);
    let cur = '';
    for (const p of parts) {
      if (p.length > maxLen) {
        if (cur) { chunks.push(cur.trim()); cur = ''; }
        for (let i = 0; i < p.length; i += maxLen)
          chunks.push(p.slice(i, i + maxLen).trim());
      } else if ((cur + ' ' + p).trim().length > maxLen) {
        if (cur) chunks.push(cur.trim());
        cur = p;
      } else {
        cur = (cur + ' ' + p).trim();
      }
    }
    if (cur) chunks.push(cur.trim());
    return chunks.filter(c => c.length > 0);
  }

  // ── Edge TTS via unofficial WebSocket ────────────────────────────────────
  // Maps short name → full SSML voice name
  const EDGE_VOICES = {
    'henri':    'fr-FR-HenriNeural',
    'denise':   'fr-FR-DeniseNeural',
    'eloise':   'fr-FR-EloiseNeural',
    'remy':     'fr-FR-RemyMultilingualNeural',
    'vivienne': 'fr-FR-VivienneMultilingualNeural',
    'guy':      'en-US-GuyNeural',
    'aria':     'en-US-AriaNeural',
  };

  async function fetchEdgeTTS(chunk, voiceName) {
    // Use corsproxy to hit the edge-tts API endpoint
    const ssmlVoice = EDGE_VOICES[voiceName.toLowerCase()] || voiceName;
    const ssml = `<speak version='1.0' xmlns='http://www.w3.org/2001/10/synthesis' xml:lang='fr-FR'><voice name='${ssmlVoice}'>${chunk.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</voice></speak>`;

    // edge-tts REST endpoint (via SpeechSynthesis proxy)
    const url = `https://edge.microsoft.com/translate/speaker/speak?text=${encodeURIComponent(chunk)}&language=fr-FR&voiceName=${ssmlVoice}`;
    // Use allorigins as CORS proxy
    const proxy = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
    const resp = await fetch(proxy);
    if (!resp.ok) throw new Error('Edge TTS proxy failed: ' + resp.status);
    const buf = await resp.arrayBuffer();
    if (buf.byteLength < 100) throw new Error('Empty response from Edge TTS');
    return buf;
  }

  // ── Google Translate TTS ──────────────────────────────────────────────────
  async function fetchGoogleTTS(chunk, lang) {
    const encoded = encodeURIComponent(chunk);
    const ttsUrl  = `https://translate.google.com/translate_tts?ie=UTF-8&q=${encoded}&tl=${lang}&client=tw-ob`;
    const proxies = [
      `https://corsproxy.io/?${encodeURIComponent(ttsUrl)}`,
      `https://api.allorigins.win/raw?url=${encodeURIComponent(ttsUrl)}`,
    ];
    for (const p of proxies) {
      try {
        const resp = await fetch(p);
        if (resp.ok) {
          const buf = await resp.arrayBuffer();
          if (buf.byteLength > 100) return buf;
        }
      } catch(e) { log('Proxy failed: ' + e.message); }
      await new Promise(r => setTimeout(r, 400));
    }
    throw new Error('All Google TTS proxies failed');
  }

  // ── Web Speech API fallback (browser native voices) ──────────────────────
  function speechSynthesisToBlob(text, lang) {
    return new Promise((resolve, reject) => {
      const utter  = new SpeechSynthesisUtterance(text);
      utter.lang   = lang + '-FR';
      utter.rate   = 0.95;
      const voices = speechSynthesis.getVoices().filter(v => v.lang.startsWith(lang));
      if (voices.length) utter.voice = voices[0];
      utter.onend  = () => resolve(null); // can't capture audio blob directly
      utter.onerror = reject;
      speechSynthesis.speak(utter);
    });
  }

  // ── Main ─────────────────────────────────────────────────────────────────
  try {
    const chunks  = splitText(text);
    const useEdge = voice && voice.toLowerCase() !== 'google';
    const method  = useEdge ? `Edge TTS (${voice})` : `Google TTS (${lang})`;
    status.textContent = `Generating with ${method}...`;
    log(`Text: ${text.length} chars | ${chunks.length} chunk(s) | Voice: ${voice || 'google'}`);

    const buffers = [];
    for (let i = 0; i < chunks.length; i++) {
      log(`Chunk ${i+1}/${chunks.length}...`);
      let buf;
      if (useEdge) {
        try {
          buf = await fetchEdgeTTS(chunks[i], voice);
        } catch(e) {
          log(`Edge TTS failed (${e.message}), falling back to Google`);
          buf = await fetchGoogleTTS(chunks[i], lang);
        }
      } else {
        buf = await fetchGoogleTTS(chunks[i], lang);
      }
      buffers.push(buf);
      log(`Chunk ${i+1} OK (${buf.byteLength} bytes)`);
    }

    const totalLen = buffers.reduce((a, b) => a + b.byteLength, 0);
    const combined = new Uint8Array(totalLen);
    let offset = 0;
    for (const buf of buffers) {
      combined.set(new Uint8Array(buf), offset);
      offset += buf.byteLength;
    }

    const blob = new Blob([combined], { type: 'audio/mpeg' });
    const url  = URL.createObjectURL(blob);
    const a    = document.createElement('a');
    a.href     = url;
    a.download = 'tts-output.mp3';
    document.body.appendChild(a);
    a.click();

    status.textContent = `Done! ${method} — ${totalLen} bytes downloaded.`;
    window.ttsComplete  = true;
    window.ttsByteSize  = totalLen;
    window.ttsMethod    = method;

  } catch(e) {
    status.textContent  = 'Error: ' + e.message;
    window.ttsError     = e.message;
  }
})();
</script>
</body>
</html>
